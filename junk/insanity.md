# Basics

A segment of a fixed size, statically partitioned into a data segment, nonce, and hash segment (for now)

```
0 . . . 8 . . . 16. . . 24. . . 32. . . 40. . . 48. . . 56. . . 64. . . 72. . . 80. . . 88
DATASEGMENTDATASEGMENTDATASEGMENTDhashsegmenthashsegmenthashsegmenNONCENONCENONCEN
```

Let's "zoom out" and set that object above as []

```
0 . . . 1 . . . 2 . . . 3 . . . 4 . . . 5 . . . 6 . . . 7 . . . 8
[]
```

We find a prime that is larger than our potential max value of our []. In that way, the prime can encapsulate the data, and recover it without error. In practice, predictable primes can be used, without sacrificing much loss to the strength ("security") of the method.

```
0 . . . 8 . . . 16. . . 24. . . 32. . . 40. . . 48. . . 56. . . 64. . . 72. . . 80. . . 88
HIIMAPRIMEIMSOGLADTOBEHEREBEINGALLUNIQUEAMONGTHESECOMPOSITEASSHOLESSPOUTINGOFFSHITABOU
```

Since the prime and the [] are so close to one another (mere bits apart), we will reassign [] to mean the prime encapsulating our original fixed size segment, [].

When we are looking for something to encapsulate the possible values generated by multiplying our data by some modular multiplicative inverse of our encapuslating prime, we are looking for values that are at least, larger than the (prime -1) mmi, multiplied by a fixed segment set to all 1's (max value). This allows all potential products from the multiplication operation to fall within the recoverable value set of subsequent encapsulating primes.

